{-# LANGUAGE AllowAmbiguousTypes, DeriveDataTypeable, TypeSynonymInstances, MultiParamTypeClasses #-}

module Main where

import Data.List
import Data.Monoid

import XMonad.Actions.GroupNavigation
import System.IO                            -- for xmonbar
import Control.Applicative ((<|>))
import XMonad --hiding ((|||))
import qualified XMonad.Core as Core
import qualified XMonad.Actions.ShowText as ShowText
import XMonad.Hooks.DynamicLog
import XMonad.Hooks.ManageDocks
import XMonad.Util.SpawnOnce
import qualified XMonad.StackSet as W
import XMonad.Util.Run
import XMonad.Util.EZConfig
import XMonad.Layout.Fullscreen
import XMonad.Actions.Navigation2D
--import XMonad.Util.Replace

import XMonad.Actions.CopyWindow            -- like cylons, except x windows
--import XMonad.Actions.Volume

import XMonad.Hooks.UrgencyHook

import XMonad.Util.NamedWindows
import Layouts
import Configuration
import qualified Keys

data XCond = WS | LD

-- | Choose an action based on the current workspace id (WS) or
-- layout description (LD).
chooseAction :: XCond -> (String -> X ()) -> X ()
chooseAction WS f = withWindowSet (f . W.currentTag)
chooseAction LD f = withWindowSet (f . description . W.layout . W.workspace . W.current)


-- | If current workspace or layout string is listed, run the associated
-- action (only the first match counts!) If it isn't listed, then run the default
-- action (marked with empty string, \"\"), or do nothing if default isn't supplied.
bindOn :: XCond -> [(String, X ())] -> X ()
bindOn xc bindings = chooseAction xc $ chooser
  where
    chooser xc =
      maybe (return ())
            snd
            (find ((xc ==) . fst) bindings <|> find (("" ==) . fst) bindings)

toggleCopyToAll :: X ()
toggleCopyToAll = wsContainingCopies >>= f
  where
    f []    = windows copyToAll
    f (_:_) = killAllOtherCopies

-- Rules which are applied to each new window.  The (optional) part before
-- '-->' is a matching rule.  The rest is an action to perform.
myManageHook :: Query (Endo WindowSet)
myManageHook = composeAll
  [ resource =? "Do"       --> doIgnore     -- Leave Gnome Do alone.
  , resource =? "Pidgin"   --> doShift w3   -- Force to IM workspace.
  , resource =? "skype"    --> doShift w7   -- Force to Skype workspace.
  , resource =? "gimp-2.6" --> doShift w8   -- Special-case the GIMP.
  , resource =? "tilda"    --> doFloat
  , resource =? "guake"    --> doFloat
  , manageDocks                             -- For xmobar
  ]


foo :: X ()
foo = do
  state <- get
  let windowSet = Core.windowset state
  ShowText.flashText def 10000 (show (W.allWindows windowSet))

---------------------------------------------------------------------------
-- Urgency Hook
---------------------------------------------------------------------------
-- from https://pbrisbin.com/posts/using_notify_osd_for_xmonad_notifications/
data LibNotifyUrgencyHook = LibNotifyUrgencyHook deriving (Read, Show)

instance UrgencyHook LibNotifyUrgencyHook where
  urgencyHook LibNotifyUrgencyHook w = do
    name     <- getName w
    Just idx <- W.findTag w <$> gets windowset
    safeSpawn "notify-send" [show name, "workspace " <> idx]

-- cf https://github.com/pjones/xmonadrc

----------------------------------------------------------------
-- HOOKS
----------------------------------------------------------------

-- Print the current xmonad status to a pipe for display by xmobar.
-- Instead of using the usual xmobarPP configuration, we use defaultPP and
-- override the colors to match the Ubuntu 10.10 "Clearlooks" theme.
-- Note that we assume "position = Bottom" appears in your xmobar config,
-- and that the Gnome bottom panel has been removed.
--
myLogHook :: Handle -> X ()
myLogHook xmobarPipe = dynamicLogWithPP xmobarPrinter
  where
    xmobarPrinter = def
      { ppOutput  = hPutStrLn xmobarPipe
      , ppCurrent = xmobarColor "black" themeHighlight . wrap "[" "]"
      , ppTitle   = xmobarColor "pink" "" . shorten 50
      , ppVisible = wrap "(" ")"
      , ppUrgent  = xmobarColor "pink" themeHighlight }


myHandleEventHook :: Event -> X All
myHandleEventHook = docksEventHook <> handleEventHook def

trayer :: String
trayer = "trayer --edge top --align center --SetDockType true --SetPartialStrut true \
         \ --expand true --width 12 --transparent true --tint 0x191970 --height 14 \
         \ --monitor primary"

myStartupHook :: X ()
myStartupHook = do -- setWMName "LG3D" -- Helps with certain Java apps, IRRC.
  spawnOnce "sh ./screenlayout/MainSetup.sh"
  spawnOnce trayer
  spawnOnce "sh ~/.fehbg"
  spawnOnce "urxvtd"
  spawnOnce "guake"
  spawnOnce "nm-applet"
  spawnOnce "fcitx"
  spawnOnce "mpd"
  spawnOnce "mate-volume-control-applet"
  spawnOnce "dunst"

main :: IO ()
main = do
  -- moved here due to big signature that was generated by the result
  let myConfig xmobarPipe =
        fullscreenSupport
        $ withUrgencyHook LibNotifyUrgencyHook
        $ def
        { workspaces  = myWorkspaces
        , modMask     = modm
        , terminal    = "urxvtc"
        , layoutHook  = myLayout
        , manageHook  = myManageHook
        , logHook     = myLogHook xmobarPipe >> historyHook
        , startupHook = myStartupHook
        , normalBorderColor  = blue
        , focusedBorderColor = pink
        , handleEventHook    = myHandleEventHook
        } `additionalKeysP` Keys.stringMap
          `additionalKeys`  Keys.maskMap
  xmobarPipe <- spawnPipe "xmobar ~/.xmonad/bar/xmobarrc"
  xmonad $ withNavigation2DConfig def (myConfig xmobarPipe)
